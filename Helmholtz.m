(* ::Package:: *)

(* ::Input:: *)
(**)
(**)
(**)
(**)
(*(*HELMHOLTZ COLLOCATION - 10 NODE TRIANGLES*)*)
(**)
(*Helmholtz Equation (General From):*)
(**)
(*In this program we will develop the Collocation version of the eigenvalue method, utilizing the Helmholtz equation.   The equation may be used to model standing waves (ex: shallow pool), acoustic vibration, or electromagnetic waves.   It is a time independent equation that represents a single state of the general transient phenomenon.*)
(**)
(*Note: Fourier series arise quite naturally in the theory of standing waves, since the normal modes of oscillation of any uniform continuous system possessing linear equations of motion take the form of spatial cos & sin waves whose wavelengths are rational fractions of the other.   The process of determining the amplitudes and phases of the normal modes of oscillation from the initial conditions is essentially equivalent to Fourier analsysis of initial conditions in space.*)
(**)
(*\[PartialD]/\[PartialD]x(Subscript[k, x]\[PartialD]\[CurlyPhi]/\[PartialD]x) + \[PartialD]/\[PartialD]y(Subscript[k, y]\[PartialD]\[CurlyPhi]/\[PartialD]y) + \[Lambda]\[CurlyPhi] = 0*)
(**)
(*\[CurlyPhi] = \[CurlyPhi](x, y) is the dependent variable. \[CurlyPhi] represents the wave height above a quiescence at location (x,y). We will assume that k = Subscript[k, x] = Subscript[k, y] is constant. \[Lambda] is the wave number. Hence we get the underlying equation:*)
(**)
(*k(\[PartialD]^2\[CurlyPhi]/\[PartialD]x^2 + \[PartialD]^2\[CurlyPhi]/\[PartialD]y^2) + \[Lambda]\[CurlyPhi] = 0. or*)
(**)
(*k(\[Del]^2\[CurlyPhi]) + \[Lambda]\[CurlyPhi] = 0.*)
(**)
(*Let u = *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]Subscript[\[Phi], e,i] be the collocation solution associated to a given finite element partition. That is u is piecewise polynomial function associated to the partition. Then we substitute the collocation solution into the PDE to get*)
(**)
(*0 = k(\[Del]^2u) + \[Lambda]u =  k(\[Del]^2( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]Subscript[\[Phi], e,i])) + \[Lambda]( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]Subscript[\[Phi], e,i]) .*)
(**)
(*0= k( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]\[Del]^2Subscript[\[Phi], e,i](Subscript[x, e,i],Subscript[y, e,i]))) + \[Lambda]( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]Subscript[\[Phi], e,i](Subscript[x, e,i],Subscript[y, e,i]))*)
(**)
(*At Collocation Point "j":*)
(**)
(*0= k( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]\[Del]^2Subscript[\[Phi], e,i](Subscript[x, e',j],Subscript[y, e',j])) + \[Lambda]( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]Subscript[\[Phi], e,i](Subscript[x, e',j],Subscript[y, e',j]))*)
(**)
(*Substituting Kronecker Delta for: Subscript[\[Phi], e,i](Subscript[x, e',j],Subscript[y, e',j]):*)
(**)
(*0= k(( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]\[Del]^2Subscript[\[Phi], e,i](Subscript[x, e',j],Subscript[y, e',j]))) + \[Lambda]( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(e, i\)]\)Subscript[a, e,i]Subscript[\[Delta], i,j]*Subscript[\[Delta], e',e])*)
(**)
(*for e=e', Subscript[\[Delta], i,j]=0 off home element, and =1 on home element \[Phi] has support in local element.  Simplifying we get:*)
(**)
(*0= k(( *)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(i\)]\)Subscript[a, e',i]\[Del]^2Subscript[\[Phi], e',,i](Subscript[x, e',j],Subscript[y, e',j]))) + \[Lambda]( Subscript[a, e',j]*1)*)
(**)
(**)
(*In Matrix Form (for collocation point "j":)*)
(*a(K+\[Lambda]M)=0*)
(*Where a=*)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(i\)]\)Subscript[a, e',i]*)
(*K=k*)
(*\!\(\*UnderscriptBox[\(\[Sum]\), \(i\)]\)\[Del]^2Subscript[\[Phi], e',,i](Subscript[x, e',j],Subscript[y, e',j])*)
(*and M= Identity*)
(**)
(**)
(**)
(**)
(**)
(**)
(**)
(**)
(*TriElements = Import["C:\\Documents and Settings\\jlintern\\Desktop\\CTElemL5D3[1].Dat"];*)
(*TriNodes= Import["C:\\Documents and Settings\\jlintern\\Desktop\\CTNodesL5D3[1].Dat"];*)
(*TriElements [[1]]//MatrixForm*)


(* ::Input:: *)
(**)
(*lList={};*)
(*j=1;*)
(*While[j<=Length[TriElements],*)
(*Subscript[l, j]={{TriNodes[[TriElements[[j]][[1]]]][[2]],TriNodes[[TriElements[[j]][[1]]]][[3]]},{TriNodes[[TriElements[[j]][[2]]]][[2]],TriNodes[[TriElements[[j]][[2]]]][[3]]},{TriNodes[[TriElements[[j]][[3]]]][[2]],TriNodes[[TriElements[[j]][[3]]]][[3]]},{TriNodes[[TriElements[[j]][[4]]]][[2]],TriNodes[[TriElements[[j]][[4]]]][[3]]},*)
(*{TriNodes[[TriElements[[j]][[5]]]][[2]],TriNodes[[TriElements[[j]][[5]]]][[3]]},{TriNodes[[TriElements[[j]][[6]]]][[2]],TriNodes[[TriElements[[j]][[6]]]][[3]]},{TriNodes[[TriElements[[j]][[7]]]][[2]],TriNodes[[TriElements[[j]][[7]]]][[3]]},{TriNodes[[TriElements[[j]][[8]]]][[2]],TriNodes[[TriElements[[j]][[8]]]][[3]]},{TriNodes[[TriElements[[j]][[9]]]][[2]],TriNodes[[TriElements[[j]][[9]]]][[3]]},{TriNodes[[TriElements[[j]][[1]]]][[2]],TriNodes[[TriElements[[j]][[1]]]][[3]]}};*)
(*AppendTo[lList,Subscript[l, j]];*)
(*j++;*)
(*]*)
(*p1=Graphics[Line[lList]];*)
(**)
(*nodelist={};*)
(*jj=1;*)
(*While[jj<=Length[TriElements],*)
(*Subscript[l, jj]={{TriNodes[[TriElements[[jj]][[1]]]][[2]],TriNodes[[TriElements[[jj]][[1]]]][[3]]},{TriNodes[[TriElements[[jj]][[2]]]][[2]],TriNodes[[TriElements[[jj]][[2]]]][[3]]},{TriNodes[[TriElements[[jj]][[3]]]][[2]],TriNodes[[TriElements[[jj]][[3]]]][[3]]},{TriNodes[[TriElements[[jj]][[4]]]][[2]],TriNodes[[TriElements[[jj]][[4]]]][[3]]},*)
(*{TriNodes[[TriElements[[jj]][[5]]]][[2]],TriNodes[[TriElements[[jj]][[5]]]][[3]]},{TriNodes[[TriElements[[jj]][[6]]]][[2]],TriNodes[[TriElements[[jj]][[6]]]][[3]]},{TriNodes[[TriElements[[jj]][[7]]]][[2]],TriNodes[[TriElements[[jj]][[7]]]][[3]]},{TriNodes[[TriElements[[jj]][[8]]]][[2]],TriNodes[[TriElements[[jj]][[8]]]][[3]]},{TriNodes[[TriElements[[jj]][[9]]]][[2]],TriNodes[[TriElements[[jj]][[9]]]][[3]]},{TriNodes[[TriElements[[jj]][[10]]]][[2]],TriNodes[[TriElements[[jj]][[10]]]][[3]]}};*)
(*AppendTo[nodelist,Subscript[l, jj]];*)
(*jj++;*)
(*]*)
(*p2=ListPlot[nodelist];*)
(*Show[p1,p2]*)
(**)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)
(**)
(*RefTriangle={{0.,0.},1/3{1.,0.},1/3{2.,0.},{1.,0.},1/3{1.,2.},1/3{2.,1.},{0.,1.},1/3{0.,2.},1/3{0.,1.},1/3{1.,1.}};*)
(*f[x_,y_]={1,x,y,x^2,x*y,y^2,x^3,x^2*y,x*y^2,y^3};*)
(*(*Create Vandermonde Matrix*)*)
(*VandermondeMat={};*)
(*i=1;*)
(*While[i<=Length[RefTriangle],*)
(*AppendTo[VandermondeMat,f[RefTriangle[[i]][[1]],RefTriangle[[i]][[2]]]];*)
(*i++;*)
(*]*)
(*Print["Vandermonde Matrix"]*)
(*Print[MatrixForm[VandermondeMat]]*)
(**)
(**)


(* ::Input:: *)
(*IDMat=IdentityMatrix[10];*)
(*PolyMat={};*)
(*ij=1;*)
(*While[ij<=Length[RefTriangle],*)
(*CoeffMat=LinearSolve[VandermondeMat,IDMat[[ij]]];*)
(*Polyct[x_,y_]=CoeffMat.f[x,y];*)
(*AppendTo[PolyMat,Polyct[x,y]];*)
(*ij++*)
(*];*)
(*Print["Reference Polynomials"]*)
(*Print[PolyMat//MatrixForm]*)


(* ::Input:: *)
(**)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*a=\[Gamma]-\[Alpha];*)
(*b=\[Delta]-\[Beta];*)
(*c=\[Sigma]-\[Alpha];*)
(*d=\[Tau]-\[Beta];*)
(*A=({*)
(* {a, c},*)
(* {b, d}*)
(*});*)
(*InvA= Inverse[A];*)
(**)
(*(*Function for sending Element to the Reference*)*)
(**)
(*(*xyvar[\[Alpha]_,\[Beta]_,\[Gamma]_,\[Delta]_,\[Sigma]_,\[Tau]_,x_,y_]=(InvA).{x,y}-(InvA).{\[Alpha],\[Beta]} to be replaced by the following:*)*)
(*xvar[\[Alpha]_,\[Beta]_,\[Gamma]_,\[Delta]_,\[Sigma]_,\[Tau]_,x_,y_]=d/Det[A]* x+ -c/Det[A]*y-d/Det[A]*\[Alpha]+c/Det[A]*\[Beta];*)
(*yvar[\[Alpha]_,\[Beta]_,\[Gamma]_,\[Delta]_,\[Sigma]_,\[Tau]_,x_,y_]=-b/Det[A]* x+ a/Det[A]*y+b/Det[A]*\[Alpha]-a/Det[A]*\[Beta];*)
(**)
(*(*Reference to Element*)*)
(*(*xyinvvar[\[Alpha]_,\[Beta]_,\[Gamma]_,\[Delta]_,\[Sigma]_,\[Tau]_,x_,y_]=A.{x,y} +{\[Alpha],\[Beta]} to be replaced with the following:*)*)
(*xinvvar[\[Alpha]_,\[Beta]_,\[Gamma]_,\[Delta]_,\[Sigma]_,\[Tau]_,x_,y_]=a*x+c*y+\[Alpha];*)
(*yinvvar[\[Alpha]_,\[Beta]_,\[Gamma]_,\[Delta]_,\[Sigma]_,\[Tau]_,x_,y_]=b*x+d*y+\[Beta];*)
(**)
(**)
(*Print["Variable Change transformation for x"];*)
(*xvar[\[Alpha],\[Beta],\[Gamma],\[Delta],\[Sigma],\[Tau],x,y]*)
(*Print["Variable Change transformation for y"];*)
(*yvar[\[Alpha],\[Beta],\[Gamma],\[Delta],\[Sigma],\[Tau],x,y]*)
(**)
(*Print["Inverse Variable Change for x"];*)
(*xinvvar[\[Alpha],\[Beta],\[Gamma],\[Delta],\[Sigma],\[Tau],x,y]//MatrixForm*)
(*Print["Inverse Variable Change for y"];*)
(*yinvvar[\[Alpha],\[Beta],\[Gamma],\[Delta],\[Sigma],\[Tau],x,y]//MatrixForm*)
(**)
(**)


(* ::Input:: *)
(*(*Initialize K/ 3 nested loops*)*)
(**)
(*GlobalK=IdentityMatrix[Length[TriNodes]];*)
(*GlobalK=0*GlobalK;*)
(*k=1;*)
(*element=1;*)
(*While[element<=Length[TriElements],*)
(*Var\[Alpha]=TriNodes[[TriElements[[element]][[1]]]][[2]];*)
(*Var\[Beta]=TriNodes[[TriElements[[element]][[1]]]][[3]];*)
(*Var\[Gamma]=TriNodes[[TriElements[[element]][[4]]]][[2]];*)
(*Var\[Delta]=TriNodes[[TriElements[[element]][[4]]]][[3]];*)
(*Var\[Sigma]=TriNodes[[TriElements[[element]][[7]]]][[2]];*)
(*Var\[Tau]=TriNodes[[TriElements[[element]][[7]]]][[3]];*)
(*xaffine[x_,y_]=xvar[Var\[Alpha],Var\[Beta],Var\[Gamma],Var\[Delta],Var\[Sigma],Var\[Tau],x,y];*)
(*yaffine[x_,y_]=yvar[Var\[Alpha],Var\[Beta],Var\[Gamma],Var\[Delta],Var\[Sigma],Var\[Tau],x,y];*)
(**)
(*ct1=1;*)
(*While[ct1<=Length[TriElements[[1]]],*)
(*\[Phi]ct[x_,y_]=PolyMat[[ct1]];*)
(*\[Phi]ref1[x_,y_]=\[Phi]ct[xaffine[x,y],yaffine[x,y]];*)
(*Lapl\[Phi][x_,y_]=D[\[Phi]ref1[x,y],{x,2}]+D[\[Phi]ref1[x,y],{y,2}];*)
(*RowID=TriElements[[element,ct1]];*)
(**)
(*ct2=1;*)
(*While[ct2<=Length[TriElements[[1]]],*)
(*ColID=TriElements[[element,ct2]];*)
(*xpt=TriNodes[[TriElements[[element]][[ct2]]]][[2]];*)
(*ypt=TriNodes[[TriElements[[element]][[ct2]]]][[3]];*)
(*Lap\[Phi]loc=Lapl\[Phi][xpt,ypt];*)
(*GlobalK[[RowID,ColID]]=Lap\[Phi]loc+GlobalK[[RowID,ColID]];*)
(*ct2++*)
(*];*)
(**)
(*ct1++*)
(*];*)
(**)
(*element++*)
(*];*)
(**)
(*Print[Lap\[Phi]loc]*)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*(*Create Dirichlet Boundary Conditions*)*)
(*GlobalK[[1]]=IdentityMatrix[Length[TriNodes]][[1]];*)
(*Print[GlobalK[[1]]//MatrixForm];*)


(* ::Input:: *)
(* (* Solve Eigensystem*)*)
(*eisys=Eigensystem[GlobalK];*)
(**)
(*(*Create List of EigenValues of GlobalK*)*)
(*lambdas=eisys[[1]];*)
(**)
(*tuples={};*)
(*a=1;*)
(*While[a<=Length[TriNodes],*)
(*b=lambdas[[a]];*)
(*imb:=If[(-.01<Im[b]<.01),0,Im[b]];*)
(*bb=Re[b]+(imb)I;*)
(*AppendTo[tuples,{a,bb}];*)
(*a++*)
(*;*)
(*]*)
(**)
(*lambdas[[1]]*)
(**)
(**)
(**)


(* ::Input:: *)
(**)
(**)


(* ::Input:: *)
(*threetuple={};*)
(*node=1;*)
(*While[node<=Length[TriNodes],*)
(*xcoord=TriNodes[[node]][[2]];*)
(*ycoord=TriNodes[[node]][[3]];*)
(*AppendTo[threetuple,{xcoord,ycoord,eisys[[2,906,node]]}];*)
(*node++*)
(*];*)
(*threetuple//MatrixForm*)


(* ::Input:: *)
(*ListPlot3D[threetuple]*)


(* ::Input:: *)
(**)
(**)
(**)
